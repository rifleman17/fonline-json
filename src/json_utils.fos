////////////////////////////////////////////////////////////////////////////////
//
//  Macros for manipulating raw characters in a string.
//
#ifdef _JSON_REV_PRE400
    #define _CharGet #(s, i)    s[i]
    #define _CharSet #(s, i, v) s[i] = v
    #define _CharAdd #(s, v)    s.resize(s.length() + 1); \
                                s[s.length() - 1] = v
    #define _CharLen #(s)       s.length()
#endif

#ifndef _JSON_REV_PRE400
    #define _CharGet #(s, i)    s.rawGet(i)
    #define _CharSet #(s, i, v) s.rawSet(i, v)
    #define _CharAdd #(s, v)    s.rawResize(s.rawLength() + 1); \
                                s.rawSet(s.rawLength() - 1, v)
    #define _CharLen #(s)       s.rawLength()
#endif

////////////////////////////////////////////////////////////////////////////////
//
// Array with JSON-compatible escape codes of control characters (0x00 - 0x1F).
//
array<string@> controlChars = {
    "\\u0000", "\\u0001", "\\u0002", "\\u0003",
    "\\u0004", "\\u0005", "\\u0006", "\\u0007", 
    "\\b",     "\\t",     "\\n",     "\\u000B",
    "\\f",     "\\r",     "\\u000E", "\\u000F",
    "\\u0010", "\\u0011", "\\u0012", "\\u0013",
    "\\u0014", "\\u0015", "\\u0016", "\\u0017", 
    "\\u0018", "\\u0019", "\\u001A", "\\u001B",
    "\\u001C", "\\u001D", "\\u001E", "\\u001F"
};

////////////////////////////////////////////////////////////////////////////////
//
// String escaping. Used in toString method of a JSON String.
//
string@ Escape(string& s)
{
    string@ escaped = "";
    uint len = _CharLen(s);
    uint8 ch = 0;
    for (uint i = 0; i < len; i++)
    {
        ch = _CharGet(s, i);
        if (ch == 34 || ch == 92)
        {
            _CharAdd(escaped, 92);
            _CharAdd(escaped, ch);
        }
        else if (ch < 32)
        {
            escaped += controlChars[ch];
        }
        else
        {
            _CharAdd(escaped, ch);
        }
    }
    return escaped;
}

////////////////////////////////////////////////////////////////////////////////
//
//  StrToDouble
//  Converts a string to a double. Used when evaluating a NUMBER token.
//  TODO: Check the precision of numbers larger than float, change return value
//  to bool, return the number by reference and false if conversion failed.
//
double StrToDouble(string@ str)
{
    int length = _CharLen(str);
    int position = _CharLen(str) - 1;
    int count = 0;
    int symbol = 0;
    int value = 0;
    int exponent = 0;

    while (position >= 0)
    {
        symbol = _CharGet(str, position);

        switch (symbol)
        {
            case 43:  // + sign
            {
                break;
            }
            case 45:  // - sign
            {
                value = -value;
                break;
            }
            case 46:  // . decimal point
            {
                exponent += -count;
                break;
            }
            case 48:  // 0
            case 49:  // 1
            case 50:  // 2
            case 51:  // 3
            case 52:  // 4
            case 53:  // 5
            case 54:  // 6
            case 55:  // 7
            case 56:  // 8
            case 57:  // 9
            {
                value += (symbol - 48) * int(pow(10, count));
                count += 1;
                break;
            }
            case 69:  // E
            case 101: // e
            {
                exponent = value;
                value = 0;
                count = 0;
                break;
            }
            default:
            {
                return 0;
            }
        }
        position -= 1;
    }
    return double(value) * double(pow(10, exponent));
}
