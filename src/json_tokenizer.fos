// Takes a JSON text and produces an array of JSON tokens

enum TokenType
{
	LEFT_SQUARE_BRACKET		= '[',
	RIGHT_SQUARE_BRACKET	= ']',
	LEFT_CURLY_BRACKET		= '{',
	RIGHT_CURLY_BRACKET		= '}',
	COMMA					= ',',
	COLON					= ':',
	TRUE					= 't',
	FALSE					= 'f',
	NULL					= 'n',
	STRING					= '"',
	NUMBER					= '#'
}

class Token
{
	TokenType type;
	string value;
	Token(TokenType type, string value)
	{
		this.type = type;
		this.value = value;
	}
	string@ name()
	{
		switch (this.type)
		{
			case LEFT_SQUARE_BRACKET:
				return "[";
			case RIGHT_SQUARE_BRACKET:
				return "]";
			case LEFT_CURLY_BRACKET:
				return "{";
			case RIGHT_CURLY_BRACKET:
				return "}";
			case COMMA:
				return ",";
			case COLON:
				return ":";
			case TRUE:
				return "true";
			case FALSE:
				return "false";
			case NULL:
				return "null";
			case STRING:
				return "string";
			case NUMBER:
				return "number";
		}
		return "unknown";
	}
}


// Returns true if reached end of text
bool growToken(string@ tokenValue, uint& tokenLength, uint& offset, uint length, uint8 character)
{
	tokenLength += 1;
	pushChar(tokenValue, character);
	offset += 1;
	return offset >= length;
}


bool eatNumberToken(string@ text, uint& offset, uint length, array<Token@>@ tokens)
{
	string tokenValue = "";
	uint tokenLength = 0;
	
	if (getChar(text, offset) == '-')
	{
		if (growToken(tokenValue, tokenLength, offset, length, '-'))
		{
			return false;
		}
	}
	if (getChar(text, offset) == '0')
	{
		if (growToken(tokenValue, tokenLength, offset, length, '0'))
		{
			tokens.insertLast(@Token(NUMBER, tokenValue));
			offset += 1;
			return true;
		}
	}
	else if (getChar(text, offset) >= '1' && getChar(text, offset) <= '9')
	{
		if (growToken(tokenValue, tokenLength, offset, length, getChar(text, offset)))
		{
			tokens.insertLast(@Token(NUMBER, tokenValue));
			offset += 1;
			return true;
		}
		while (offset < length)
		{
			if (getChar(text, offset) >= '0' && getChar(text, offset) <= '9')
			{
				if (growToken(tokenValue, tokenLength, offset, length, getChar(text, offset)))
				{
					tokens.insertLast(@Token(NUMBER, tokenValue));
					offset += 1;
					return true;	
				}
			}
			else
			{
				break;
			}
		}
	}
	if (getChar(text, offset) == '.')
	{
		if (growToken(tokenValue, tokenLength, offset, length, getChar(text, offset)))
		{
			return false;
		}
		while (offset < length)
		{
			if (getChar(text, offset) >= '0' && getChar(text, offset) <= '9')
			{
				if (growToken(tokenValue, tokenLength, offset, length, getChar(text, offset)))
				{
					tokens.insertLast(@Token(NUMBER, tokenValue));
					offset += 1;
					return true;	
				}
			}
			else
			{
				break;
			}
		}
	}
	if (getChar(text, offset) == 'e' || getChar(text, offset) == 'E') {
		if (growToken(tokenValue, tokenLength, offset, length, getChar(text, offset)))
		{
			return false;
		}
	}
	if (getChar(text, offset) == '+' || getChar(text, offset) == '-') {
		if (growToken(tokenValue, tokenLength, offset, length, getChar(text, offset)))
		{
			return false;
		}
	}
	if (getChar(text, offset) >= '0' && getChar(text, offset) <= '9')
	{
		if (growToken(tokenValue, tokenLength, offset, length, getChar(text, offset)))
		{
			tokens.insertLast(@Token(NUMBER, tokenValue));
			offset += 1;
			return true;
		}
	}
	while (offset < length)
	{
		if (getChar(text, offset) >= '0' && getChar(text, offset) <= '9')
		{
			if (growToken(tokenValue, tokenLength, offset, length, getChar(text, offset)))
			{
				tokens.insertLast(@Token(NUMBER, tokenValue));
				offset += 1;
				return true;
			}
		}
		else
		{
			break;
		}
	}
	tokens.insertLast(@Token(NUMBER, tokenValue));
	return true;
}


bool eatStringToken(string@ text, uint& offset, uint length, array<Token@>@ tokens)
{
	string tokenValue = "";
	uint tokenLength = 0;
	offset += 1;

	while (offset < length)
	{
		if (getChar(text, offset) == '"') // end of string
		{
			tokens.insertLast(@Token(STRING, tokenValue));
			offset += 1;
			return true;
		}
		else if (getChar(text, offset) == 92) // escape sequence
		{
			offset += 1;
			if (offset >= length)
			{
				return false;
			}
			switch (getChar(text, offset))
			{
			case '"':
			case '/':
			case 92:
				growToken(tokenValue, tokenLength, offset, length, getChar(text, offset));
				break;
			case 'b':
				growToken(tokenValue, tokenLength, offset, length, 8);
				break;
			case 'f':
				growToken(tokenValue, tokenLength, offset, length, 12);
				break;
			case 'n':
				growToken(tokenValue, tokenLength, offset, length, 10);
				break;
			case 'r':
				growToken(tokenValue, tokenLength, offset, length, 13);
				break;
			case 't':
				growToken(tokenValue, tokenLength, offset, length, 9);
				break;
			case 'u': // TODO: implement unicode sequence
				offset += 5;
				if (offset >= length)
				{
					return false;
				}
			}
		}
		else
		{
			growToken(tokenValue, tokenLength, offset, length, getChar(text, offset));
		}
	}
	return false;
}


bool eatLiteralToken(string@ text, uint& offset, string@ match, array<Token@>@ tokens)
{
	uint tokenLength = getLength(match);

	if (offset + tokenLength > getLength(text))
	{
		return false;
	}
	for (uint i = 1; i < tokenLength; i += 1)
	{
		if (getChar(text, offset + i) != getChar(match, i))
		{
			return false;
		}
	}
	tokens.insertLast(@Token(TokenType(getChar(text, offset)), ""));
	offset += tokenLength;
	return true;
}


void eatStructuralToken(string@ text, uint& offset, array<Token@>@ tokens)
{
	tokens.insertLast(@Token(TokenType(getChar(text, offset)), ""));
	offset += 1;
}


void eatWhitespace(string@ text, uint& offset, uint length)
{
	offset += 1;
	while (offset < length)
	{
		switch (getChar(text, offset))
		{
			case 9:
			case 10:
			case 13:
			case 32:
				offset += 1;
				break;
			default:
				return;
		}
	}
}


bool tokenize(string@ text, array<Token@>@ tokens)
{
	uint length = getLength(text);
	uint offset = 0;
	uint8 symbol;

	while (offset < length)
	{
		symbol = getChar(text, offset);
		switch (symbol)
		{
			case 9:
			case 10:
			case 13:
			case 32:
			{
				eatWhitespace(text, offset, length);
				break;
			}
			case COMMA:
			case COLON:
			case LEFT_SQUARE_BRACKET:
			case RIGHT_SQUARE_BRACKET:
			case LEFT_CURLY_BRACKET:
			case RIGHT_CURLY_BRACKET:
			{
				eatStructuralToken(text, offset, tokens);
				break;
			}
			case TRUE:
				if (!eatLiteralToken(text, offset, "true", tokens))
				{
					return false;
				}
				break;
			case FALSE:
				if (!eatLiteralToken(text, offset, "false", tokens))
				{
					Log("Failed to eat literal false token " + symbol);
					return false;
				}
				break;
			case NULL:
				if (!eatLiteralToken(text, offset, "null", tokens))
				{
					return false;
				}
				break;
			case STRING:
			{
				if (!eatStringToken(text, offset, length, tokens))
				{
					return false;
				}
				break;
			}
			case '-':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			{
				if (!eatNumberToken(text, offset, length, tokens))
				{
					return false;
				}
				break;
			}
			default:
			{
				return false;
			}
		}
	}
	return true;
}
